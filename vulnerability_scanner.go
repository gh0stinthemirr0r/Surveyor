package surveyor

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"go.uber.org/zap"
)

// VulnerabilityScanner provides advanced vulnerability scanning capabilities
type VulnerabilityScanner struct {
	config      *Config
	logger      *zap.Logger
	vulnDB      *VulnerabilityDatabase
	mu          sync.RWMutex
	lastUpdate  time.Time
}

// Vulnerability represents a known vulnerability
type Vulnerability struct {
	ID               string    `json:"id"`              // CVE or other ID
	Title            string    `json:"title"`           // Short description
	Description      string    `json:"description"`     // Full description
	CVSS             float64   `json:"cvss"`            // CVSS score
	Severity         string    `json:"severity"`        // Low, Medium, High, Critical
	AffectedSoftware []string  `json:"affected_software"` // List of affected software
	DisclosureDate   time.Time `json:"disclosure_date"` // Date vulnerability was disclosed
	References       []string  `json:"references"`      // Reference URLs
	ExploitAvailable bool      `json:"exploit_available"` // Whether an exploit is known
	PatchAvailable   bool      `json:"patch_available"`   // Whether a patch is available
	Mitigations      []string  `json:"mitigations"`      // Possible mitigations
}

// VulnerabilityDatabase holds the vulnerability database
type VulnerabilityDatabase struct {
	Vulnerabilities map[string]Vulnerability // Mapped by ID
	ServiceMap      map[string][]string      // Maps service name to vulnerability IDs
	LastUpdated     time.Time
	Sources         []string
}

// VulnerabilityScanResult contains the result of a vulnerability scan
type VulnerabilityScanResult struct {
	Host              string
	ScannedServices   map[int]string         // Port -> Service
	Vulnerabilities   map[string]Vulnerability // ID -> Vulnerability
	SeverityCounts    map[string]int         // Severity -> Count
	HighestSeverity   string
	TotalVulnCount    int
	ExploitableCount  int
	ScanTime          time.Time
	RecommendedFixes  []string
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config *Config, logger *zap.Logger) *VulnerabilityScanner {
	return &VulnerabilityScanner{
		config:     config,
		logger:     logger.With(zap.String("component", "vuln_scanner")),
		vulnDB:     &VulnerabilityDatabase{
			Vulnerabilities: make(map[string]Vulnerability),
			ServiceMap:      make(map[string][]string),
		},
	}
}

// LoadVulnerabilityDatabase loads the vulnerability database from sources
func (vs *VulnerabilityScanner) LoadVulnerabilityDatabase(ctx context.Context) error {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	
	// Check if we need to update the database
	if vs.vulnDB.LastUpdated.IsZero() || 
		time.Since(vs.vulnDB.LastUpdated) > parseUpdateFrequency(vs.config.VulnDBUpdateFrequency) {
		vs.logger.Info("Loading vulnerability database")
		
		// Create database directory if it doesn't exist
		if vs.config.VulnDBPath != "" {
			if err := os.MkdirAll(vs.config.VulnDBPath, 0755); err != nil {
				vs.logger.Error("Failed to create vulnerability database directory", zap.Error(err))
				return err
			}
		}
		
		// Initialize database
		vs.vulnDB.Vulnerabilities = make(map[string]Vulnerability)
		vs.vulnDB.ServiceMap = make(map[string][]string)
		
		// Load from each configured source
		for _, source := range vs.config.VulnDBSources {
			switch strings.ToLower(source) {
			case "local":
				err := vs.loadLocalDatabase()
				if err != nil {
					vs.logger.Error("Error loading local vulnerability database", zap.Error(err))
				}
			case "nvd":
				err := vs.loadNVDDatabase(ctx)
				if err != nil {
					vs.logger.Error("Error loading NVD vulnerability database", zap.Error(err))
				}
			case "exploitdb":
				err := vs.loadExploitDB(ctx)
				if err != nil {
					vs.logger.Error("Error loading ExploitDB database", zap.Error(err))
				}
			default:
				vs.logger.Warn("Unknown vulnerability database source", zap.String("source", source))
			}
		}
		
		// Update timestamp
		vs.vulnDB.LastUpdated = time.Now()
		vs.vulnDB.Sources = vs.config.VulnDBSources
		
		vs.logger.Info("Vulnerability database loaded",
			zap.Int("vulnerability_count", len(vs.vulnDB.Vulnerabilities)),
			zap.Int("service_mappings", len(vs.vulnDB.ServiceMap)),
			zap.Time("updated", vs.vulnDB.LastUpdated),
		)
	}
	
	return nil
}

// loadLocalDatabase loads vulnerabilities from a local database file
func (vs *VulnerabilityScanner) loadLocalDatabase() error {
	if vs.config.VulnDBPath == "" {
		return fmt.Errorf("vulnerability database path not configured")
	}
	
	// Path to local database file
	dbPath := filepath.Join(vs.config.VulnDBPath, "local_vulns.json")
	
	// Check if file exists
	if _, err := os.Stat(dbPath); os.IsNotExist(err) {
		vs.logger.Warn("Local vulnerability database file doesn't exist", zap.String("path", dbPath))
		return nil
	}
	
	// Open and read the file
	file, err := os.Open(dbPath)
	if err != nil {
		return err
	}
	defer file.Close()
	
	// Parse JSON
	var localVulns struct {
		Vulnerabilities []Vulnerability `json:"vulnerabilities"`
		ServiceMappings map[string][]string `json:"service_mappings"`
	}
	
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&localVulns); err != nil {
		return err
	}
	
	// Add to our database
	for _, vuln := range localVulns.Vulnerabilities {
		vs.vulnDB.Vulnerabilities[vuln.ID] = vuln
	}
	
	// Add service mappings
	for service, vulnIDs := range localVulns.ServiceMappings {
		vs.vulnDB.ServiceMap[service] = append(vs.vulnDB.ServiceMap[service], vulnIDs...)
	}
	
	vs.logger.Info("Loaded local vulnerability database",
		zap.Int("vuln_count", len(localVulns.Vulnerabilities)),
		zap.Int("service_mappings", len(localVulns.ServiceMappings)),
	)
	
	return nil
}

// loadNVDDatabase loads vulnerabilities from the NVD (National Vulnerability Database)
func (vs *VulnerabilityScanner) loadNVDDatabase(ctx context.Context) error {
	// This is a simplified implementation since real NVD API usage would be extensive
	vs.logger.Info("Loading vulnerabilities from NVD")
	
	// Example URL - in a real implementation this would use proper API endpoints with rate limiting
	nvdUrl := "https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=10"
	
	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", nvdUrl, nil)
	if err != nil {
		return err
	}
	
	// Add user agent
	req.Header.Add("User-Agent", "Surveyor Vulnerability Scanner/1.0")
	
	// Send request
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("NVD API returned status code %d", resp.StatusCode)
	}
	
	// Parse response
	// This is a simplified parsing - real implementation would be more comprehensive
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	
	// Parse JSON
	var nvdResponse struct {
		Vulnerabilities []struct {
			CVE struct {
				ID string `json:"id"`
				Descriptions []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
				Metrics struct {
					CVSS struct {
						BaseScore float64 `json:"baseScore"`
						BaseSeverity string `json:"baseSeverity"`
					} `json:"cvssMetricV31"`
				} `json:"metrics"`
				References []struct {
					URL string `json:"url"`
				} `json:"references"`
				Published string `json:"published"`
			} `json:"cve"`
		} `json:"vulnerabilities"`
	}
	
	if err := json.Unmarshal(body, &nvdResponse); err != nil {
		return err
	}
	
	// Process vulnerabilities
	for _, item := range nvdResponse.Vulnerabilities {
		cve := item.CVE
		
		// Find English description
		description := ""
		for _, desc := range cve.Descriptions {
			if desc.Lang == "en" {
				description = desc.Value
				break
			}
		}
		
		// Collect references
		var references []string
		for _, ref := range cve.References {
			references = append(references, ref.URL)
		}
		
		// Parse published date
		publishedDate, _ := time.Parse(time.RFC3339, cve.Published)
		
		// Create vulnerability record
		vuln := Vulnerability{
			ID:             cve.ID,
			Title:          description,
			Description:    description,
			CVSS:           cve.Metrics.CVSS.BaseScore,
			Severity:       cve.Metrics.CVSS.BaseSeverity,
			DisclosureDate: publishedDate,
			References:     references,
		}
		
		// Add to database
		vs.vulnDB.Vulnerabilities[vuln.ID] = vuln
	}
	
	vs.logger.Info("Loaded vulnerabilities from NVD",
		zap.Int("new_vulns", len(nvdResponse.Vulnerabilities)),
	)
	
	return nil
}

// loadExploitDB loads exploit information from Exploit-DB
func (vs *VulnerabilityScanner) loadExploitDB(ctx context.Context) error {
	// This is a simplified implementation
	vs.logger.Info("Loading exploit information from Exploit-DB")
	
	// In a real implementation, this would download and parse exploit-db data
	// For now, just add some example data
	
	// Example: mark some existing vulnerabilities as exploitable
	for id, vuln := range vs.vulnDB.Vulnerabilities {
		// Randomly mark some vulnerabilities as exploitable (for demonstration)
		if id[len(id)-1] == '0' || id[len(id)-1] == '5' {
			vuln.ExploitAvailable = true
			vs.vulnDB.Vulnerabilities[id] = vuln
		}
	}
	
	vs.logger.Info("Updated vulnerabilities with exploit information")
	
	return nil
}

// ScanHost scans a host for vulnerabilities
func (vs *VulnerabilityScanner) ScanHost(ctx context.Context, host string, services map[int]string) (*VulnerabilityScanResult, error) {
	vs.logger.Info("Starting vulnerability scan", zap.String("host", host))
	
	// Ensure database is loaded
	if err := vs.LoadVulnerabilityDatabase(ctx); err != nil {
		return nil, fmt.Errorf("failed to load vulnerability database: %w", err)
	}
	
	result := &VulnerabilityScanResult{
		Host:             host,
		ScannedServices:  services,
		Vulnerabilities:  make(map[string]Vulnerability),
		SeverityCounts:   make(map[string]int),
		ScanTime:         time.Now(),
	}
	
	// Lock for reading the database
	vs.mu.RLock()
	defer vs.mu.RUnlock()
	
	// Check each service for vulnerabilities
	for _, serviceName := range services {
		vs.checkServiceVulnerabilities(serviceName, result)
	}
	
	// Calculate summary statistics
	result.TotalVulnCount = len(result.Vulnerabilities)
	
	// Count exploitable vulnerabilities
	for _, vuln := range result.Vulnerabilities {
		if vuln.ExploitAvailable {
			result.ExploitableCount++
		}
	}
	
	// Determine highest severity
	if result.SeverityCounts["Critical"] > 0 {
		result.HighestSeverity = "Critical"
	} else if result.SeverityCounts["High"] > 0 {
		result.HighestSeverity = "High"
	} else if result.SeverityCounts["Medium"] > 0 {
		result.HighestSeverity = "Medium"
	} else if result.SeverityCounts["Low"] > 0 {
		result.HighestSeverity = "Low"
	} else {
		result.HighestSeverity = "None"
	}
	
	// Generate recommended fixes
	result.RecommendedFixes = vs.generateRecommendations(result)
	
	vs.logger.Info("Vulnerability scan completed",
		zap.String("host", host),
		zap.Int("service_count", len(services)),
		zap.Int("vulnerability_count", result.TotalVulnCount),
		zap.String("highest_severity", result.HighestSeverity),
	)
	
	return result, nil
}

// checkServiceVulnerabilities checks a service for known vulnerabilities
func (vs *VulnerabilityScanner) checkServiceVulnerabilities(serviceName string, result *VulnerabilityScanResult) {
	// Clean service name for matching (remove version info for broader matching)
	cleanServiceName := serviceName
	if idx := strings.Index(cleanServiceName, ":"); idx != -1 {
		cleanServiceName = cleanServiceName[:idx]
	}
	
	// Get vulnerabilities for this service
	vulnIDs, exists := vs.vulnDB.ServiceMap[cleanServiceName]
	if !exists {
		return
	}
	
	// Check if any vulnerabilities match the CVSS threshold
	for _, vulnID := range vulnIDs {
		vuln, exists := vs.vulnDB.Vulnerabilities[vulnID]
		if !exists {
			continue
		}
		
		// Apply CVSS filter if configured
		if vs.config.CVSSMinScore > 0 && vuln.CVSS < vs.config.CVSSMinScore {
			continue
		}
		
		// Apply severity filter if configured
		if vs.config.CVESeverityFilter != "" && !matchesSeverityFilter(vuln.Severity, vs.config.CVESeverityFilter) {
			continue
		}
		
		// Apply age filter if configured
		if vs.config.MaxCVEAge > 0 {
			maxAge := time.Now().AddDate(0, 0, -vs.config.MaxCVEAge)
			if vuln.DisclosureDate.Before(maxAge) {
				continue
			}
		}
		
		// Add to results
		result.Vulnerabilities[vulnID] = vuln
		result.SeverityCounts[vuln.Severity]++
	}
	
	// If we have exact version info, check for version-specific vulnerabilities
	if idx := strings.Index(serviceName, ":"); idx != -1 {
		version := serviceName[idx+1:]
		
		// Get vulnerabilities for the exact service:version
		exactVulnIDs, exists := vs.vulnDB.ServiceMap[serviceName]
		if exists {
			for _, vulnID := range exactVulnIDs {
				vuln, exists := vs.vulnDB.Vulnerabilities[vulnID]
				if !exists {
					continue
				}
				
				// Apply filters
				if vs.config.CVSSMinScore > 0 && vuln.CVSS < vs.config.CVSSMinScore {
					continue
				}
				
				if vs.config.CVESeverityFilter != "" && !matchesSeverityFilter(vuln.Severity, vs.config.CVESeverityFilter) {
					continue
				}
				
				// Add to results if not already added
				if _, exists := result.Vulnerabilities[vulnID]; !exists {
					result.Vulnerabilities[vulnID] = vuln
					result.SeverityCounts[vuln.Severity]++
				}
			}
		}
	}
}

// generateRecommendations generates recommended fixes for vulnerabilities
func (vs *VulnerabilityScanner) generateRecommendations(result *VulnerabilityScanResult) []string {
	var recommendations []string
	
	// Group vulnerabilities by service for more coherent recommendations
	serviceVulns := make(map[string][]Vulnerability)
	
	for _, service := range result.ScannedServices {
		serviceVulns[service] = []Vulnerability{}
	}
	
	for _, vuln := range result.Vulnerabilities {
		for port, service := range result.ScannedServices {
			// If we can connect this vulnerability to a specific service
			for _, affectedSoftware := range vuln.AffectedSoftware {
				if strings.Contains(service, affectedSoftware) {
					serviceVulns[service] = append(serviceVulns[service], vuln)
					break
				}
			}
		}
	}
	
	// Generate recommendations for each service
	for service, vulns := range serviceVulns {
		if len(vulns) == 0 {
			continue
		}
		
		// Sort vulnerabilities by severity (highest first)
		sort.Slice(vulns, func(i, j int) bool {
			return severityRank(vulns[i].Severity) > severityRank(vulns[j].Severity)
		})
		
		// General recommendation
		rec := fmt.Sprintf("Service %s has %d vulnerabilities. ", service, len(vulns))
		
		// Version-specific recommendation
		if strings.Contains(service, ":") {
			parts := strings.SplitN(service, ":", 2)
			rec += fmt.Sprintf("Consider upgrading %s from version %s to the latest version. ", parts[0], parts[1])
		} else {
			rec += "Consider upgrading to the latest version. "
		}
		
		// If there are critical vulnerabilities, highlight them
		criticalCount := 0
		for _, vuln := range vulns {
			if vuln.Severity == "Critical" {
				criticalCount++
			}
		}
		
		if criticalCount > 0 {
			rec += fmt.Sprintf("URGENT: %d critical vulnerabilities found that should be addressed immediately!", criticalCount)
		}
		
		recommendations = append(recommendations, rec)
		
		// Add specific mitigation advice for top vulnerabilities
		for i, vuln := range vulns {
			if i >= 3 { // Limit to top 3
				break
			}
			
			if len(vuln.Mitigations) > 0 {
				mitigationRec := fmt.Sprintf("For %s (%s, CVSS %.1f): %s", 
					vuln.ID, vuln.Severity, vuln.CVSS, vuln.Mitigations[0])
				recommendations = append(recommendations, mitigationRec)
			}
		}
	}
	
	// General recommendations
	if result.ExploitableCount > 0 {
		recommendations = append(recommendations, 
			fmt.Sprintf("ALERT: %d vulnerabilities have known exploits available. Immediate attention recommended.", 
				result.ExploitableCount))
	}
	
	return recommendations
}

// parseUpdateFrequency parses the update frequency string
func parseUpdateFrequency(freq string) time.Duration {
	switch strings.ToLower(freq) {
	case "hourly":
		return 1 * time.Hour
	case "daily":
		return 24 * time.Hour
	case "weekly":
		return 7 * 24 * time.Hour
	case "monthly":
		return 30 * 24 * time.Hour
	default:
		// Default to daily
		return 24 * time.Hour
	}
}

// matchesSeverityFilter checks if a vulnerability severity matches the filter
func matchesSeverityFilter(severity, filter string) bool {
	severityRanks := map[string]int{
		"Critical": 4,
		"High":     3,
		"Medium":   2,
		"Low":      1,
		"None":     0,
	}
	
	vulnRank := severityRanks[severity]
	filterRank := severityRanks[filter]
	
	return vulnRank >= filterRank
}

// severityRank returns a numeric rank for a severity
func severityRank(severity string) int {
	switch severity {
	case "Critical":
		return 4
	case "High":
		return 3
	case "Medium":
		return 2
	case "Low":
		return 1
	default:
		return 0
	}
}

// GenerateVulnerabilityReport generates a text report of vulnerabilities
func GenerateVulnerabilityReport(result *VulnerabilityScanResult) string {
	var report strings.Builder
	
	report.WriteString(fmt.Sprintf("Vulnerability Scan Report for %s\n", result.Host))
	report.WriteString(fmt.Sprintf("Scan Time: %s\n\n", result.ScanTime.Format(time.RFC3339)))
	
	report.WriteString("Summary:\n")
	report.WriteString(fmt.Sprintf("  Total Vulnerabilities: %d\n", result.TotalVulnCount))
	report.WriteString(fmt.Sprintf("  Highest Severity: %s\n", result.HighestSeverity))
	report.WriteString(fmt.Sprintf("  Exploitable Vulnerabilities: %d\n\n", result.ExploitableCount))
	
	report.WriteString("Severity Distribution:\n")
	for _, severity := range []string{"Critical", "High", "Medium", "Low"} {
		report.WriteString(fmt.Sprintf("  %s: %d\n", severity, result.SeverityCounts[severity]))
	}
	report.WriteString("\n")
	
	report.WriteString("Scanned Services:\n")
	for port, service := range result.ScannedServices {
		report.WriteString(fmt.Sprintf("  [%d] %s\n", port, service))
	}
	report.WriteString("\n")
	
	if len(result.Vulnerabilities) > 0 {
		report.WriteString("Vulnerabilities:\n")
		
		// Sort vulnerabilities by severity
		var vulnList []Vulnerability
		for _, vuln := range result.Vulnerabilities {
			vulnList = append(vulnList, vuln)
		}
		
		sort.Slice(vulnList, func(i, j int) bool {
			return severityRank(vulnList[i].Severity) > severityRank(vulnList[j].Severity)
		})
		
		for _, vuln := range vulnList {
			report.WriteString(fmt.Sprintf("  [%s] %s\n", vuln.Severity, vuln.ID))
			report.WriteString(fmt.Sprintf("    CVSS: %.1f\n", vuln.CVSS))
			report.WriteString(fmt.Sprintf("    Description: %s\n", vuln.Description))
			if vuln.ExploitAvailable {
				report.WriteString("    EXPLOIT AVAILABLE\n")
			}
			report.WriteString("\n")
		}
	}
	
	if len(result.RecommendedFixes) > 0 {
		report.WriteString("Recommended Actions:\n")
		for _, rec := range result.RecommendedFixes {
			report.WriteString(fmt.Sprintf("  - %s\n", rec))
		}
	}
	
	return report.String()
}