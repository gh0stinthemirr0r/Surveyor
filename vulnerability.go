package surveyor

import (
	"bufio"
	"encoding/csv"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"go.uber.org/zap"
)

// Vulnerability errors
var (
	ErrVulnDBNotFound        = errors.New("vulnerability database not found")
	ErrVulnDBInvalid         = errors.New("invalid vulnerability database format")
	ErrVulnDBDownloadFailed  = errors.New("failed to download vulnerability database")
	ErrVulnDBParseError      = errors.New("failed to parse vulnerability data")
	ErrNoVulnerabilitiesFound = errors.New("no vulnerabilities found")
)

// VulnerabilitySource defines where vulnerability data is loaded from
type VulnerabilitySource string

const (
	// LocalDatabase uses a local vulnerability database
	LocalDatabase VulnerabilitySource = "local"
	// NVDSource uses the National Vulnerability Database
	NVDSource VulnerabilitySource = "nvd"
	// CVEDetailsSource uses the CVE Details database
	CVEDetailsSource VulnerabilitySource = "cvedetails"
	// VulnersSource uses the Vulners database
	VulnersSource VulnerabilitySource = "vulners"
	// ExploitDBSource uses the Exploit Database
	ExploitDBSource VulnerabilitySource = "exploitdb"
)

// Vulnerability represents a vulnerability entry
type Vulnerability struct {
	ID           string    `json:"id"`
	Title        string    `json:"title"`
	Description  string    `json:"description"`
	CVSS         float64   `json:"cvss_score"`
	Published    time.Time `json:"published"`
	LastModified time.Time `json:"last_modified"`
	References   []string  `json:"references"`
	Affects      []string  `json:"affects"`
	Severity     string    `json:"severity"`
	ExploitAvailable bool  `json:"exploit_available"`
	ExploitURI   string    `json:"exploit_uri,omitempty"`
	FixAvailable bool      `json:"fix_available"`
	FixVersion   string    `json:"fix_version,omitempty"`
	Source       string    `json:"source"`
	FullData     map[string]interface{} `json:"full_data,omitempty"`
}

// VulnerabilityMatcher describes a pattern for matching vulnerabilities to services
type VulnerabilityMatcher struct {
	ServiceRegex  *regexp.Regexp
	VersionRegex  *regexp.Regexp
	DefaultCVEs   []string
}

// VulnerabilityDatabase manages vulnerability data
type VulnerabilityDatabase struct {
	sources               []VulnerabilitySource
	vulnerabilities       map[string]Vulnerability // Indexed by ID (e.g., CVE-2021-1234)
	serviceMatchers       map[string][]VulnerabilityMatcher // Indexed by service name
	versionMatchers       map[string]map[string][]string // service -> version -> CVEs
	defaultVulnsByService map[string][]string // Common vulnerabilities by service
	lastUpdate           time.Time
	databasePath         string
	logger               *zap.Logger
	mu                   sync.RWMutex
}

// NewVulnerabilityDatabase creates a new vulnerability database
func NewVulnerabilityDatabase(databasePath string, logger *zap.Logger) *VulnerabilityDatabase {
	return &VulnerabilityDatabase{
		sources:               []VulnerabilitySource{LocalDatabase},
		vulnerabilities:       make(map[string]Vulnerability),
		serviceMatchers:       make(map[string][]VulnerabilityMatcher),
		versionMatchers:       make(map[string]map[string][]string),
		defaultVulnsByService: make(map[string][]string),
		databasePath:          databasePath,
		logger:                logger.With(zap.String("component", "vuln_database")),
	}
}

// Init initializes the vulnerability database
func (vdb *VulnerabilityDatabase) Init(config *Config) error {
	vdb.mu.Lock()
	defer vdb.mu.Unlock()

	// Create the database directory if it doesn't exist
	if err := os.MkdirAll(vdb.databasePath, 0755); err != nil {
		return fmt.Errorf("failed to create vulnerability database directory: %w", err)
	}

	// Initialize sources from config
	if config.VulnerabilityDB.Sources != nil && len(config.VulnerabilityDB.Sources) > 0 {
		vdb.sources = make([]VulnerabilitySource, 0)
		for _, src := range config.VulnerabilityDB.Sources {
			vdb.sources = append(vdb.sources, VulnerabilitySource(src))
		}
	}

	// Load local database
	err := vdb.loadLocalDatabase()
	if err != nil {
		vdb.logger.Warn("Failed to load local vulnerability database", zap.Error(err))
		
		// If auto-update is enabled and local load failed, try to download
		if config.VulnerabilityDB.AutoUpdate {
			vdb.logger.Info("Attempting to download vulnerability database")
			if err := vdb.UpdateDatabase(config.VulnerabilityDB.UpdateInterval); err != nil {
				vdb.logger.Warn("Failed to update vulnerability database", zap.Error(err))
				// Continue even if update fails - we'll just have an empty database
			}
		}
	}

	// Initialize default matchers for common services
	vdb.initDefaultMatchers()

	vdb.logger.Info("Vulnerability database initialized", 
		zap.Int("vulnerabilities", len(vdb.vulnerabilities)),
		zap.Int("services", len(vdb.serviceMatchers)),
		zap.Time("last_updated", vdb.lastUpdate))

	return nil
}

// loadLocalDatabase loads vulnerability data from local files
func (vdb *VulnerabilityDatabase) loadLocalDatabase() error {
	// Check main database file
	mainDBPath := filepath.Join(vdb.databasePath, "vulnerabilities.json")
	if _, err := os.Stat(mainDBPath); os.IsNotExist(err) {
		return fmt.Errorf("%w: %s", ErrVulnDBNotFound, mainDBPath)
	}

	// Read and parse the main database
	data, err := os.ReadFile(mainDBPath)
	if err != nil {
		return fmt.Errorf("failed to read vulnerability database: %w", err)
	}

	// Unmarshal into a map of vulnerabilities
	var vulns map[string]Vulnerability
	if err := json.Unmarshal(data, &vulns); err != nil {
		return fmt.Errorf("%w: %v", ErrVulnDBInvalid, err)
	}

	vdb.vulnerabilities = vulns

	// Load service mappings
	mappingsPath := filepath.Join(vdb.databasePath, "service_mappings.json")
	if _, err := os.Stat(mappingsPath); !os.IsNotExist(err) {
		data, err := os.ReadFile(mappingsPath)
		if err == nil {
			var mappings map[string]map[string][]string
			if err := json.Unmarshal(data, &mappings); err == nil {
				vdb.versionMatchers = mappings
			} else {
				vdb.logger.Warn("Failed to parse service mappings", zap.Error(err))
			}
		}
	}

	// Get the last update time from file metadata
	fileInfo, err := os.Stat(mainDBPath)
	if err == nil {
		vdb.lastUpdate = fileInfo.ModTime()
	} else {
		vdb.lastUpdate = time.Now()
	}

	return nil
}

// initDefaultMatchers sets up default vulnerability patterns for common services
func (vdb *VulnerabilityDatabase) initDefaultMatchers() {
	// Add matchers for common services
	sshMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)ssh|openssh`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2018-15473", "CVE-2016-0777"},
	}
	vdb.serviceMatchers["ssh"] = append(vdb.serviceMatchers["ssh"], sshMatcher)
	
	// OpenSSH version-specific matchers
	if vdb.versionMatchers["ssh"] == nil {
		vdb.versionMatchers["ssh"] = make(map[string][]string)
	}
	vdb.versionMatchers["ssh"]["7.4"] = []string{"CVE-2018-15473", "CVE-2017-15906"}
	vdb.versionMatchers["ssh"]["8.0"] = []string{"CVE-2019-16905"}
	
	// HTTP server matchers
	apacheMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)apache|httpd`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2020-11984", "CVE-2019-0211"},
	}
	vdb.serviceMatchers["http"] = append(vdb.serviceMatchers["http"], apacheMatcher)
	
	nginxMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)nginx`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2019-9511", "CVE-2018-16845"},
	}
	vdb.serviceMatchers["http"] = append(vdb.serviceMatchers["http"], nginxMatcher)
	
	// Add more default matchers for common services
	ftpMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)vsftpd`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2011-2523"},
	}
	vdb.serviceMatchers["ftp"] = append(vdb.serviceMatchers["ftp"], ftpMatcher)
	
	smtpMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)exim`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2019-15846", "CVE-2019-16928"},
	}
	vdb.serviceMatchers["smtp"] = append(vdb.serviceMatchers["smtp"], smtpMatcher)
	
	mysqlMatcher := VulnerabilityMatcher{
		ServiceRegex: regexp.MustCompile(`(?i)mysql`),
		VersionRegex: nil,
		DefaultCVEs:  []string{"CVE-2020-2922", "CVE-2020-2812"},
	}
	vdb.serviceMatchers["mysql"] = append(vdb.serviceMatchers["mysql"], mysqlMatcher)

	// Add to default vulnerabilities map for fallback
	vdb.defaultVulnsByService["ssh"] = []string{"CVE-2018-15473", "CVE-2016-0777"}
	vdb.defaultVulnsByService["http"] = []string{"CVE-2020-11984", "CVE-2019-9511"}
	vdb.defaultVulnsByService["ftp"] = []string{"CVE-2011-2523"}
	vdb.defaultVulnsByService["smtp"] = []string{"CVE-2019-15846"}
	vdb.defaultVulnsByService["mysql"] = []string{"CVE-2020-2922"}
}

// UpdateDatabase downloads and updates the vulnerability database
func (vdb *VulnerabilityDatabase) UpdateDatabase(updateInterval time.Duration) error {
	vdb.mu.Lock()
	defer vdb.mu.Unlock()

	// Check if update is needed based on interval
	if !vdb.lastUpdate.IsZero() && time.Since(vdb.lastUpdate) < updateInterval {
		vdb.logger.Debug("Skipping vulnerability database update, last update too recent",
			zap.Time("last_update", vdb.lastUpdate),
			zap.Duration("interval", updateInterval))
		return nil
	}

	var errors []error
	var updated bool

	for _, source := range vdb.sources {
		var err error
		switch source {
		case LocalDatabase:
			// Local database should already be loaded
			continue
		case NVDSource:
			err = vdb.updateFromNVD()
		case CVEDetailsSource:
			err = vdb.updateFromCVEDetails()
		case VulnersSource:
			err = vdb.updateFromVulners()
		case ExploitDBSource:
			err = vdb.updateFromExploitDB()
		default:
			err = fmt.Errorf("unsupported vulnerability source: %s", source)
		}

		if err != nil {
			errors = append(errors, fmt.Errorf("error updating from %s: %w", source, err))
		} else {
			updated = true
		}
	}

	// If any source was successfully updated, save the database
	if updated {
		if err := vdb.saveDatabase(); err != nil {
			errors = append(errors, fmt.Errorf("error saving database: %w", err))
		} else {
			vdb.lastUpdate = time.Now()
		}
	}

	// If there were errors, return a combined error
	if len(errors) > 0 {
		errorMessages := make([]string, len(errors))
		for i, err := range errors {
			errorMessages[i] = err.Error()
		}
		return fmt.Errorf("%w: %s", ErrVulnDBDownloadFailed, strings.Join(errorMessages, "; "))
	}

	return nil
}

// updateFromNVD updates the database from the National Vulnerability Database
func (vdb *VulnerabilityDatabase) updateFromNVD() error {
	// In a real implementation, this would download and parse data from NVD
	// For this example, we'll provide a simplified implementation
	vdb.logger.Info("Updating from NVD (National Vulnerability Database)")
	
	// NVD provides JSON feeds by year
	currentYear := time.Now().Year()
	
	// Get the last 3 years of data for the example
	for year := currentYear; year >= currentYear-2; year-- {
		url := fmt.Sprintf("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%d.json.gz", year)
		vdb.logger.Debug("Downloading NVD data", zap.String("url", url))
		
		// In a real implementation we would:
		// 1. Download the gzipped JSON file
		// 2. Decompress it
		// 3. Parse the JSON
		// 4. Extract relevant vulnerabilities
		// 5. Store them in our database
		
		// For this example, we'll just simulate with a delay
		time.Sleep(100 * time.Millisecond)
	}
	
	// Add sample data for demonstration
	vdb.addSampleNVDData()
	
	return nil
}

// addSampleNVDData adds sample vulnerability data for demonstration
func (vdb *VulnerabilityDatabase) addSampleNVDData() {
	// Sample vulnerabilities
	sampleVulns := []Vulnerability{
		{
			ID:           "CVE-2021-44228",
			Title:        "Log4j Remote Code Execution",
			Description:  "Apache Log4j2 <=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.",
			CVSS:         10.0,
			Published:    time.Date(2021, 12, 10, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2021, 12, 20, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://logging.apache.org/log4j/2.x/security.html"},
			Affects:      []string{"apache:log4j"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			FixAvailable: true,
			FixVersion:   "2.15.0",
			Source:       "NVD",
		},
		{
			ID:           "CVE-2019-11043",
			Title:        "PHP-FPM Remote Code Execution",
			Description:  "In PHP versions 7.1.x below 7.1.33, 7.2.x below 7.2.24 and 7.3.x below 7.3.11 in certain configurations of FPM setup it is possible to cause FPM module to write past allocated buffers into the space reserved for FCGI protocol data, thus opening the possibility of remote code execution.",
			CVSS:         9.8,
			Published:    time.Date(2019, 10, 30, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2019, 11, 2, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://bugs.php.net/bug.php?id=78599"},
			Affects:      []string{"php:php"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			FixAvailable: true,
			FixVersion:   "7.3.11",
			Source:       "NVD",
		},
	}

	// Add to the database
	for _, vuln := range sampleVulns {
		vdb.vulnerabilities[vuln.ID] = vuln
	}
}

// updateFromCVEDetails updates the database from CVE Details
func (vdb *VulnerabilityDatabase) updateFromCVEDetails() error {
	// Simplified example implementation
	vdb.logger.Info("Updating from CVE Details")
	
	// Add sample data for demonstration
	vdb.addSampleCVEDetailsData()
	
	return nil
}

// addSampleCVEDetailsData adds sample data for demonstration
func (vdb *VulnerabilityDatabase) addSampleCVEDetailsData() {
	// Sample vulnerabilities
	sampleVulns := []Vulnerability{
		{
			ID:           "CVE-2020-1472",
			Title:        "Zerologon Windows Netlogon Elevation of Privilege",
			Description:  "The Netlogon Remote Protocol (MS-NRPC) is a critical Windows component that authenticates users and machines. An elevation of privilege vulnerability exists when an attacker establishes a vulnerable connection to a domain controller using MS-NRPC.",
			CVSS:         10.0,
			Published:    time.Date(2020, 8, 17, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2020, 9, 14, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1472"},
			Affects:      []string{"microsoft:windows_server"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			FixAvailable: true,
			Source:       "CVE Details",
		},
		{
			ID:           "CVE-2017-0144",
			Title:        "EternalBlue SMB Remote Code Execution",
			Description:  "The SMBv1 server in Microsoft Windows has a buffer overflow vulnerability that could allow remote code execution when processing specially crafted packets.",
			CVSS:         9.3,
			Published:    time.Date(2017, 3, 14, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2017, 5, 12, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010"},
			Affects:      []string{"microsoft:windows"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			FixAvailable: true,
			Source:       "CVE Details",
		},
	}

	// Add to the database
	for _, vuln := range sampleVulns {
		vdb.vulnerabilities[vuln.ID] = vuln
	}
}

// updateFromVulners updates the database from Vulners
func (vdb *VulnerabilityDatabase) updateFromVulners() error {
	// Simplified example implementation
	vdb.logger.Info("Updating from Vulners")
	
	// Add sample data for demonstration
	vdb.addSampleVulnersData()
	
	return nil
}

// addSampleVulnersData adds sample data for demonstration
func (vdb *VulnerabilityDatabase) addSampleVulnersData() {
	// Sample vulnerabilities
	sampleVulns := []Vulnerability{
		{
			ID:           "CVE-2018-15473",
			Title:        "OpenSSH Username Enumeration",
			Description:  "OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.",
			CVSS:         5.3,
			Published:    time.Date(2018, 8, 17, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2018, 8, 20, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"},
			Affects:      []string{"openssh:openssh"},
			Severity:     "MEDIUM",
			ExploitAvailable: true,
			FixAvailable: true,
			FixVersion:   "7.8",
			Source:       "Vulners",
		},
		{
			ID:           "CVE-2019-11510",
			Title:        "Pulse Secure VPN Arbitrary File Reading",
			Description:  "An arbitrary file reading vulnerability in Pulse Secure SSL VPN versions 8.2 and 9.0 allows remote unauthenticated attackers to send a specially crafted URI to perform an arbitrary file reading vulnerability that leads to exposure of sensitive information.",
			CVSS:         10.0,
			Published:    time.Date(2019, 4, 24, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2019, 5, 8, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101"},
			Affects:      []string{"pulse_secure:pulse_connect_secure"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			FixAvailable: true,
			Source:       "Vulners",
		},
	}

	// Add to the database
	for _, vuln := range sampleVulns {
		vdb.vulnerabilities[vuln.ID] = vuln
	}
}

// updateFromExploitDB updates the database from Exploit DB
func (vdb *VulnerabilityDatabase) updateFromExploitDB() error {
	// Simplified example implementation
	vdb.logger.Info("Updating from Exploit DB")
	
	// Add sample data for demonstration
	vdb.addSampleExploitDBData()
	
	return nil
}

// addSampleExploitDBData adds sample data for demonstration
func (vdb *VulnerabilityDatabase) addSampleExploitDBData() {
	// Sample vulnerabilities with exploit data
	sampleVulns := []Vulnerability{
		{
			ID:           "CVE-2020-0796",
			Title:        "SMBGhost - Windows SMBv3 Remote Code Execution",
			Description:  "A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3) protocol handles certain requests. An attacker who successfully exploited the vulnerability could gain the ability to execute code on the target server or client.",
			CVSS:         10.0,
			Published:    time.Date(2020, 3, 12, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2020, 3, 20, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796"},
			Affects:      []string{"microsoft:windows_10", "microsoft:windows_server_2019"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			ExploitURI:   "https://www.exploit-db.com/exploits/48216",
			FixAvailable: true,
			Source:       "Exploit DB",
		},
		{
			ID:           "CVE-2019-19781",
			Title:        "Citrix ADC Directory Traversal",
			Description:  "A directory traversal vulnerability in Citrix Application Delivery Controller (ADC) and Gateway 10.5, 11.1, 12.0, 12.1, and 13.0 allows remote unauthenticated attackers to read components from the file system or perform command execution.",
			CVSS:         9.8,
			Published:    time.Date(2019, 12, 17, 0, 0, 0, 0, time.UTC),
			LastModified: time.Date(2020, 1, 8, 0, 0, 0, 0, time.UTC),
			References:   []string{"https://support.citrix.com/article/CTX267027"},
			Affects:      []string{"citrix:application_delivery_controller", "citrix:gateway"},
			Severity:     "CRITICAL",
			ExploitAvailable: true,
			ExploitURI:   "https://www.exploit-db.com/exploits/49488",
			FixAvailable: true,
			Source:       "Exploit DB",
		},
	}

	// Add to the database
	for _, vuln := range sampleVulns {
		vdb.vulnerabilities[vuln.ID] = vuln
	}
}

// saveDatabase saves the vulnerability database to disk
func (vdb *VulnerabilityDatabase) saveDatabase() error {
	// Save main vulnerability database
	mainDBPath := filepath.Join(vdb.databasePath, "vulnerabilities.json")
	data, err := json.MarshalIndent(vdb.vulnerabilities, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal vulnerability database: %w", err)
	}

	if err := os.WriteFile(mainDBPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write vulnerability database: %w", err)
	}

	// Save service mappings
	mappingsPath := filepath.Join(vdb.databasePath, "service_mappings.json")
	mappingsData, err := json.MarshalIndent(vdb.versionMatchers, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal service mappings: %w", err)
	}

	if err := os.WriteFile(mappingsPath, mappingsData, 0644); err != nil {
		return fmt.Errorf("failed to write service mappings: %w", err)
	}

	return nil
}

// CheckServiceVulnerabilities checks for vulnerabilities in a detected service
func (vdb *VulnerabilityDatabase) CheckServiceVulnerabilities(service string, version string) ([]Vulnerability, error) {
	vdb.mu.RLock()
	defer vdb.mu.RUnlock()

	if len(vdb.vulnerabilities) == 0 {
		return nil, ErrVulnDBNotFound
	}

	var vulnerabilities []Vulnerability
	var cveIDs []string

	// First check for exact service and version match
	if version != "" {
		if versionMap, ok := vdb.versionMatchers[service]; ok {
			if cves, ok := versionMap[version]; ok {
				cveIDs = append(cveIDs, cves...)
			}
		}
	}

	// If no exact match, try using matchers
	if len(cveIDs) == 0 && service != "" {
		if matchers, ok := vdb.serviceMatchers[service]; ok {
			for _, matcher := range matchers {
				// If service name matches the regex
				if matcher.ServiceRegex != nil && matcher.ServiceRegex.MatchString(service) {
					// If there's a version regex and it matches, or no version regex
					if version == "" || matcher.VersionRegex == nil || matcher.VersionRegex.MatchString(version) {
						cveIDs = append(cveIDs, matcher.DefaultCVEs...)
					}
				}
			}
		}
	}

	// If still no match, try the default vulnerabilities for this service
	if len(cveIDs) == 0 && service != "" {
		if defaultCVEs, ok := vdb.defaultVulnsByService[service]; ok {
			cveIDs = append(cveIDs, defaultCVEs...)
		}
	}

	// Deduplicate CVE IDs
	cveMap := make(map[string]bool)
	for _, id := range cveIDs {
		cveMap[id] = true
	}

	// Look up each vulnerability
	for id := range cveMap {
		if vuln, ok := vdb.vulnerabilities[id]; ok {
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	if len(vulnerabilities) == 0 {
		return nil, ErrNoVulnerabilitiesFound
	}

	return vulnerabilities, nil
}

// SearchVulnerabilities searches for vulnerabilities by keyword
func (vdb *VulnerabilityDatabase) SearchVulnerabilities(keyword string) ([]Vulnerability, error) {
	vdb.mu.RLock()
	defer vdb.mu.RUnlock()

	if len(vdb.vulnerabilities) == 0 {
		return nil, ErrVulnDBNotFound
	}

	var results []Vulnerability
	keyword = strings.ToLower(keyword)

	for _, vuln := range vdb.vulnerabilities {
		if strings.Contains(strings.ToLower(vuln.ID), keyword) ||
			strings.Contains(strings.ToLower(vuln.Title), keyword) ||
			strings.Contains(strings.ToLower(vuln.Description), keyword) {
			results = append(results, vuln)
		}
	}

	if len(results) == 0 {
		return nil, ErrNoVulnerabilitiesFound
	}

	return results, nil
}

// GetVulnerability retrieves a specific vulnerability by ID
func (vdb *VulnerabilityDatabase) GetVulnerability(id string) (Vulnerability, error) {
	vdb.mu.RLock()
	defer vdb.mu.RUnlock()

	vuln, ok := vdb.vulnerabilities[id]
	if !ok {
		return Vulnerability{}, fmt.Errorf("vulnerability not found: %s", id)
	}

	return vuln, nil
}

// Statistics returns statistics about the vulnerability database
func (vdb *VulnerabilityDatabase) Statistics() map[string]interface{} {
	vdb.mu.RLock()
	defer vdb.mu.RUnlock()

	stats := make(map[string]interface{})
	stats["total_vulnerabilities"] = len(vdb.vulnerabilities)
	stats["total_services"] = len(vdb.serviceMatchers)
	stats["last_update"] = vdb.lastUpdate

	// Count vulnerabilities by severity
	severityCounts := make(map[string]int)
	for _, vuln := range vdb.vulnerabilities {
		severityCounts[vuln.Severity]++
	}
	stats["by_severity"] = severityCounts

	// Count vulnerabilities by source
	sourceCounts := make(map[string]int)
	for _, vuln := range vdb.vulnerabilities {
		sourceCounts[vuln.Source]++
	}
	stats["by_source"] = sourceCounts

	// Count vulnerabilities with exploits
	exploitableCount := 0
	for _, vuln := range vdb.vulnerabilities {
		if vuln.ExploitAvailable {
			exploitableCount++
		}
	}
	stats["exploitable"] = exploitableCount

	return stats
}

// EnhanceScanResult adds vulnerability information to a scan result
func (vdb *VulnerabilityDatabase) EnhanceScanResult(result *ScanResult) {
	if result == nil {
		return
	}

	var allVulnerabilities []string

	// Check vulnerabilities for each detected service
	for port, serviceInfo := range result.Services {
		// Extract service name and version if available
		parts := strings.Split(serviceInfo, ":")
		service := parts[0]
		version := ""
		if len(parts) > 1 {
			version = parts[1]
		}

		// Check for vulnerabilities
		vulns, err := vdb.CheckServiceVulnerabilities(service, version)
		if err == nil && len(vulns) > 0 {
			// Add vulnerability IDs to the result
			for _, vuln := range vulns {
				// Add to overall list only if not already there
				if !contains(allVulnerabilities, vuln.ID) {
					allVulnerabilities = append(allVulnerabilities, vuln.ID)
				}

				// Add detailed information to additional info
				if result.AdditionalInfo == nil {
					result.AdditionalInfo = make(map[string]string)
				}

				// Add a detailed entry for this port/service
				key := fmt.Sprintf("vuln_%d_%s", port, vuln.ID)
				result.AdditionalInfo[key] = fmt.Sprintf("%s (CVSS: %.1f, Severity: %s)", 
					vuln.Title, vuln.CVSS, vuln.Severity)
			}
		}
	}

	// Set the consolidated vulnerabilities list
	result.Vulnerabilities = allVulnerabilities
}

// contains checks if a string slice contains a value
func contains(slice []string, value string) bool {
	for _, item := range slice {
		if item == value {
			return true
		}
	}
	return false
}

// ImportCVEData imports CVE data from a CSV file
func (vdb *VulnerabilityDatabase) ImportCVEData(filePath string) error {
	vdb.mu.Lock()
	defer vdb.mu.Unlock()

	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open CVE data file: %w", err)
	}
	defer file.Close()

	reader := csv.NewReader(file)
	
	// Skip header
	_, err = reader.Read()
	if err != nil {
		return fmt.Errorf("failed to read CSV header: %w", err)
	}

	var imported int
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("error reading CSV: %w", err)
		}

		// Validate record has enough fields
		if len(record) < 5 {
			continue
		}

		// Parse the record into a vulnerability
		id := record[0]
		publishedDate, _ := time.Parse("2006-01-02", record[1])
		modifiedDate, _ := time.Parse("2006-01-02", record[2])
		
		// Parse CVSS score
		cvss := 0.0
		if record[3] != "" {
			cvss, _ = strconv.ParseFloat(record[3], 64)
		}

		// Determine severity based on CVSS
		severity := "LOW"
		if cvss >= 7.0 {
			severity = "HIGH"
		} else if cvss >= 4.0 {
			severity = "MEDIUM"
		}

		vuln := Vulnerability{
			ID:           id,
			Title:        record[4],
			Description:  record[5],
			CVSS:         cvss,
			Published:    publishedDate,
			LastModified: modifiedDate,
			Severity:     severity,
			Source:       "Imported",
		}

		// Add references if available
		if len(record) > 6 && record[6] != "" {
			vuln.References = strings.Split(record[6], ";")
		}

		// Store in the database
		vdb.vulnerabilities[id] = vuln
		imported++
	}

	vdb.logger.Info("Imported CVE data", zap.Int("imported", imported), zap.String("file", filePath))
	
	// Save the updated database
	return vdb.saveDatabase()
}

// ExportVulnerabilities exports vulnerabilities to a CSV file
func (vdb *VulnerabilityDatabase) ExportVulnerabilities(filePath string) error {
	vdb.mu.RLock()
	defer vdb.mu.RUnlock()

	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create export file: %w", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write header
	header := []string{"ID", "Title", "Description", "CVSS", "Severity", "Published", "Last Modified", "References", "Source"}
	if err := writer.Write(header); err != nil {
		return fmt.Errorf("error writing CSV header: %w", err)
	}

	// Write vulnerabilities
	for _, vuln := range vdb.vulnerabilities {
		record := []string{
			vuln.ID,
			vuln.Title,
			vuln.Description,
			fmt.Sprintf("%.1f", vuln.CVSS),
			vuln.Severity,
			vuln.Published.Format("2006-01-02"),
			vuln.LastModified.Format("2006-01-02"),
			strings.Join(vuln.References, ";"),
			vuln.Source,
		}
		if err := writer.Write(record); err != nil {
			return fmt.Errorf("error writing CSV record: %w", err)
		}
	}

	vdb.logger.Info("Exported vulnerabilities", zap.Int("count", len(vdb.vulnerabilities)), zap.String("file", filePath))
	return nil
}